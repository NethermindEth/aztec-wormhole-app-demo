{"noir_version":"1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec","name":"ZKPassportCredentialEmitter","functions":[{"name":"process_message","hash":"7182326998060069209","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"TL3LsjS7jpz5LnvcgyRAXHhepQeyVl9kZVamMmtJo3p5rQAIuk+0P1edn45gBDwjI5G5/vOf/+f//a//67/9l3/77//ff/yPf/71f/7nP//1//+3f//3f/tv/+Xf/+P//r/+57/9x3//+//9z39+3/8T559/6f/xT/4J//vP+udf+fcf+edf6/f3X/37r/z9d//9d//91/751/cf7/9E/yf//o/fvz393/O7/133v3L/q/e/+/7X7n/9/jfuf+965663fr+BNSADOrAHbMAHYiAHZuU1K69Zec3Ka1Zes/KaldesvGblNSuvWVlmZZmVZVaWWVlmZZmVZVaWWVlmZZmVdVbWWVlnZZ2VdVbWWVlnZZ2VdVbWWXnPyntW3rPynpX3rLxn5T0r71l5z8p7VrZZ2WZlm5VtVrZZ2WZlm5VtVrZZ2WZln5V9VvZZ2Wdln5X9b2X5feADMZAD50L8BtaADOjAHpiVY1aOb+X1QQ6cC1+vNawBGdCBb+X9wbdyfuADMZAD58LXeg1/K6t8IAM6sAf+Vlb9wAdi4Fv527GvBz+QrwcbvpXPBzKgA3vABnwgBnLgXPh6sGFWXrPympXXrPz14F4f+EAM5MC58PVgwxqQAR3YA7OyzMoyK8usLLOyzso6K+usrLOyzso6K+usrLOyzso6K+9Zec/Ke1b+enDrB3vABnwgBnLgXPh6sGENyMCsbLOyzco2K9usbLOyzco+K/us7LOyz8o+K/us7LOyz8o+K/usHLNyzMoxK8esHLNyzMoxK8esHLNyzMo5K+esnLNyzso5K+esnLNyzso5K+esfGblMyufWfnMymdWPrPymZXPrHxm5XNX1t9vYA3IgA7sARvwgRjIgW/lv6bWrwcb1oAM6MAesAEfiIEcmJVlVpZZWWbl6sHzwR6wgb+VbX8QAzlwLnw92LAGZEAH9oANzMo6K+usrLPyvomkew3IgA7sARvwgRjIgZt1arOyzco2K9us/PWgxQc24AMxkAPnwteDDWtABnRgVvZZ2Wdln5V9Vv560P5eSvTrwYY1IAM6sAdswAdiIAdm5ZyVc1bOWfnrQbcP9oAN+EAM5MC58PVgwxqQgVn5zMpnVj6z8pmVz6x87sr79xtYAzKgA3vABnwgBnJgVl6z8pqV16y8ZuU1K69Zec3Ka1Zes/KalWVWlllZZmWZlWVWlllZZmWZlWVWlllZZ2WdlXVW1llZZ2WdlXVW1llZZ2WdlfesvGflPSvvWXnPyntW3rPynpX3rLxnZZuVbVa2WdlmZZuVbVa2WdlmZZuVbVb2WdlnZZ+VfVb2WdlnZZ+VfVb2Wdln5ZiVY1aOWTlm5ZiVY1aOWTlm5ZiVY1bOWTln5ZyVpwf39OCeHtzTg3t6cE8P7unBPT24pwf39OCeHtzTg3t6cE8P7unBPT24pwdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHbXrQpgdtetCmB2160KYHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB3160KcHfXrQpwd9etCnB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6MKYHY3owpgdjejCmB2N6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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"2405857079137275542","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"TL3LkjW7jpz5LnusweIFAFGv0gNZq1uSlVmZykyXUb28MuAE3Se1P6/zJ53BIHzFikBG/sc///9//S//57//53/9H//t3//XP//y//zHP//lf/7rv/3bv/73//xv//7//b//+1///X/8/X//45/f939W/PMv6z/9s84//+J//8l//uX8p3/23/80fn//HX//nX//nX//3X//XX///ftne9//2v2v3//G/e+5/0381373v+P+d97/3vHsjmd3PLvj2R3P7nh2x/M7nt/x/I7ndzy/4/kdz+94fsfzO57f8eKOF3e8uOPFHS/ueHHHizte3PHijhd3vHPHO3e8c8c7d7xzxzt3vHPHO3e8c8c7d7y84+UdL+94ecfLO17e8fKOl3e8vOPlHW/8fg2jYTasht1gDd4QDaehRx498uiRR488euTRI48eefTIo0cePfLokeffyPP3wWiYDathN1iDN0TDacgLq0dePfL6Rh4frIbdYA3eEA2n4Rv5r17GV0jzfDAaZsNq2A3W8Dfymh9Ew2nIC19JrfXBaJgN38jfin1lBbCGb+T8IBpOQ174igswGmbDatgN1tAje4/sPbL3yF+Z7W99vjoDzIbVsBuswRui4TTkhdMjnx759MinRz498umRT498euTTI58eOXvk7JGzR84eOXvk7JGzR84e+SvB/Z2drwY/mF8NAkbDbFgNu8EavCEaTkOPPHrk0SOPHnn0yKNHHj3y6JFHjzx65NEjzx559sizR5498uyRZ488e+TZI88eefbIq0dePfLqkVePvHrk1SOvHnn1yKtHXj3y7pF3j7x75N0j7x5598i7R9498u6Rd49sPbL1yNYjW49sPbL1yNYjW49sPbL1yN4je4/sPbL3yF8Nbv/AGrwhGk5DXqgaLBgNs2E19MjRI0ePHD1y1WB+kBeqBgv+Rrb9wWxYDbvBGrwhGk5DXvhqENAjZ4+cPXL2yHkTaaY3RMNpuIm0fr+G0TAbVsNusAZviIbT8M05/uCrQcBomA2rYTdYgzdEw2nokWePPHvk2SPPHvmrQTsfWIM3RMNpyAtfDQJGw2xYDT3y6pFXj7x65LqYtA/ywleDgNEwG1bDbrAGb4iGHnn3yNYjW49sPbL1yNYjW49sPbL1yNYjW4/sPbL3yN4je4/sPbL3yN4je4/sPbL3yNEjR48cPXL0yNEjR48cPXL0yNEjR498euTTI58e+fTIp0c+PfLpkU+PfHrk0yNnj5w9cvbI2SNnj5w9cvbI2SNnj5x35P37NYyG2bAadoM1eEM0nIYeefTIo0cePfLokUePPHrk0SOPHnn0yKNHnj3y7JFnjzx75Nkjzx559sizR5498uyRV4+8euTVI68eefXIq0dePfLqkbsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3De6uwd01uLsGd9fg7hrcXYO7a3B3DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DUbXYHQNRtdgdA1G12B0DZ6uwdM1eLoGT9fg6Ro8XYOna/B0DZ6uwdM1eLoGT9fg6Ro8XYOna/B0DZ6uwdM1eLoGT9fg6Ro8XYOna/B0DZ6uwdM1eLoGT9fg6Ro8XYOna/B0DZ6uwdM1eLoGT9fg6Ro8XYOna/B0DZ6uwdM1eLoGT9fg6Ro8XYOna/B0DZ6uwdM1eLoGT9fg6Ro8VYPng91gDX8jx/wgGk5DXvhqEDAaZsNq2A3W0CN7j+w9svfI0SNHjxw9cvTI0SNHjxw9cvTI0SNHj3x65NMjnx759MinRz498umRT498euTTI2ePnD1y9sjZI2ePnD1y9sjZI2ePnHfk/P0aRsNsWA27wRq8IRpOQ488euTRI48eefTIo0cePfLokUePPHrk0SPPHnn2yLNHnj3y7JFnjzx75Nkjzx559sirR1498uqRV4+8euTVI68eefXIq0dePfLukXePvHvk3SPvHnn3yLtH3j3y7pF3j2w9svXI1iNbj2w9svXIXYPZNZhdg9k1mF2D2TWYXYPZNZhdg9k1mF2D2TWYXYPZNZhdg9k1mF2D2TWYXYPZNZhdg9k1mF2D2TWYXYPZNZhdg9k1mF2D2TWYXYPZNZhdg9k1mF2D2TWYXYPZNZhdg9k1mF2D2TWYXYPZNfj3jP73aDyaj9aj/cge+aN4dB49j/E8xvMYz2M8j/E8xvMYz2M8j/E8xvOYz2M+j/k85vOYz2M+j/k85vOYz2M+j/U81vNYz2M9j/U81vNYz2M9j/U81vPYz2M/j/089vPYz2M/j/089vPYz2M/D3se9jzsedjzsOdhz8Oehz0Pex72PPx5+PPw5+HPw5+HPw9/Hv48/Hn484jnEc8jnkc8j3ge8TziecTziOcRz+M8j/M8zvM4z+M8j/M8zvM4z+M8j/M88nnk88jnkc8jn0c+j3we+Tzyebw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDofr87Hq/Px6ny8Oh+vzser8/HqfLw6H6/Ox6vz8ep8vDqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Op+vzuer8/nqfL46n6/O56vz+ep8vjqfr87nq/P56ny+Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr86rMym+fuVqTbo0Hs1H69F+ZI/8UTw6j57HeR7neZzncZ7HeR7neZzncZ7HeR7neeTzyOeRzyOfRz6PfB75PPJ55PPI9qjGpUvj0Xy0Hu1H9sgfxaPz6HmM5zGex3ge43mM5zGex3ge43mM5zGex3we83nM5zGfx3we83nM5zGfx3we83ms57Gex3oe63ms57Gex3oe63ms57Gex34e+3ns57Gfx34e+3ns57Gfx34e+3nY87DnYc/Dnoc9D3se9jzsedjzsOfhz8Ofhz8Pfx7+PPx5+PPw5+HP49X5fnW+X53vV+f71Xm1QIUX2SN/FI/Oo2yqOgeNR/PRevQ8zvM4z+M8j/M8zvPI55HPI59HPo98Hvk88nnk88jnke1RzVGXxqP5aD3aj+yRP4pH59HzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo/5PObzWM9jPY/1PNbzWM9jPY/1PNbzWM9jPY/9PPbz2M9jP4/9PPbz2M9jP4/9PPbzsOdhz8Oehz0Pex72POx52POw52HPw5+HPw9/Hv48/Hn48/Dn4c/Dn4c/j3ge8TziecTzeHVur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur87t1bm9OrdX5/bq3F6d26tze3Vur8791bm/Oq8WrMBvRa1H+5E98kfx6DzKpqpz0Hj0PMbzGM9jPI/xPMbzGM9jPI/5PObzmM9jPo/5PObzmM9jPo+vzo8VZdNX55fGo/loPdqP7JE/ikfPo34Ftdb+q/NL49F8tB7tR/bIH8Wj8+h52POw52HP46vzc4r2I3vkj+LReZRNX51fGo/mo+fhz8Ofhz8Pfx7+PPx5xPOI5xHPI55HPI94HvE84nnE84jncZ7HeR7neXx1nqNoP7JHfx4ZRfHoPPrzyBrlq/NL49H8fhv5V7iIm2hEJwbxELOxmr0aB3ESF3ETjVhu9ZuI9SuxFw+x3L4rqWoAaxzESVzETTSiE4N4iHSbdJt0m3Sb5WaFm2hEJwbxEPPh+hEHcRLptui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oNuh26Hboduh26Hboduh26HboduhW9It6ZZ0S7ol3ZJuSbekW9Itn9v5/YiDOImLuIlGdGIQD5Fug26DboNug26DboNug26DboNug26TbsiSKJzERdxEIzoxiIeYD5ElQLotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJuQbegW9At6Hboduh26Hboduh26Hboduh26HbolnRLuiXdkm5Jt6Rb0i3plnTL55a/H3EQJ3ERN9GITgziIdJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SjVmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWVLPg+F6jNKpd8GJlycVBnMRF3EQjOjGIdMt2m9VD2DiI5TYKF3ETjejEIB5iPqwsuTiIdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt0M7oZ3YxuRjejm9HN6GZ0M7oZ3ZxulSXDCidxEcvtFBrRiUE8xHxYWXJxECdxEekWdAu6Bd2CbkG3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7ekW9It6ZZ0S7ol3ZJuSbekWz43vDTs4iBO4iJuohGdGMRDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMkmrGHN9rS2d1YzYO4iQu4iYa0YlBPES6bbptum26VZbMWbiJRnRiEA8xH1aWXBzESaSb0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3oduh26Hboduh26Hboduh26HboduiWdEu6Jd2Sbkm3pFvSLemWdMvnVj2djYM4iYu4iUZ0YhAPkW6DboNug26DboNug26DboNulSXfC39ntXlerCy5WG5ZOImLuIlGdGIQDzEfIkuAdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3o5vRzehmdDO6Gd2cbk43p5vTzenmdHO6Od2cbk63oFvQLegWdAu6Bd2CbkG3oFvQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAt6ZZ0S7ol3ZJuSbekW9It6ZbPzX4/4iBO4iJuohGdGMRDpNug26DboNug26DboNug26DboNug26Qbs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEswR9r9+fN5noe73oxCAeYj6sLLk4iJO4iHSbdJt0m3SrLFlemA8rSy4O4iQu4iYa0YlBpNui26bbptum26bbptum26bbpltlybLCfFhZcnEQJ3ERN9GITgwi3YxuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJuQbegW9At6Hboduh26Hboduh26Hboduh26HbolnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdGIQD5Fug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbsySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJL0Pe6ojCIh5gPkSXAQZzERdxEI9Jt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt0O3Q7dDt0O3Q7dDt0O3ypLvL91N9L1ezIeVJfWHy9D3enESF3ETjejEIB5iXlzoe704iJO4iJtoRCcG8RDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oNuh26Hboduh26Hboduh26HboduhW9It6ZZ0S7ol3ZJuSbekW9KNWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKYJYNZMpglg1kymCWDWTKY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","expression_width":{"Bounded":{"width":4}}},{"name":"verify_and_publish","hash":"9688972555623740797","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"contractProofData","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::ContractProofData","fields":[{"name":"vkeys","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::vkeys","fields":[{"name":"vkey_a","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_b","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_c","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_d","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_e","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_f","type":{"kind":"array","length":128,"type":{"kind":"field"}}}]}},{"name":"proofs","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::proofs","fields":[{"name":"proof_a","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_b","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_c","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_d","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_e","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_f","type":{"kind":"array","length":456,"type":{"kind":"field"}}}]}},{"name":"vkey_hashes","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::vkey_hashes","fields":[{"name":"vkey_hash_a","type":{"kind":"field"}},{"name":"vkey_hash_b","type":{"kind":"field"}},{"name":"vkey_hash_c","type":{"kind":"field"}},{"name":"vkey_hash_d","type":{"kind":"field"}},{"name":"vkey_hash_e","type":{"kind":"field"}},{"name":"vkey_hash_f","type":{"kind":"field"}}]}},{"name":"public_inputs","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::public_inputs","fields":[{"name":"input_a","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_b","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_c","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"input_d","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"input_e","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"input_f","type":{"kind":"array","length":5,"type":{"kind":"field"}}}]}}]},"visibility":"private"},{"name":"msg","type":{"kind":"array","length":7,"type":{"kind":"array","length":31,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"wormhole_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"include_by_timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"note_hash_read_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_read_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"key_validation_requests_and_generators","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hashes","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifiers","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_call_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_call_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_logs","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_class_logs_hashes","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"4456244908619624852":{"error_kind":"string","string":"Preimage mismatch"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"8403890105346170400":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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dR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1Hl3n0XUeXefRdR5d59F1nh1wYUnedJpuUxRlnYNG02xaTbupPaI9oj2iPbLOPb8v49c0mmbTatpN1uRNp+k2tcdoj9Eeoz1Ge4z2GO0x2mO0x2iP0R6zPWZ7zPaY7THbY7bHbI/ZHrM9Znus9ljtsdpjtcdqj9Ueqz1We6z2WO2x22O3x26P3R67PXZ77PbY7bHbY7eHtYe1h7WHtYe1h7WHtYe1R3710++XGI35FVAPx4crcRIXcRON6MRDvMRozK+Keki3Q7dDt0O3Q7dDt0O3Q7dDt0u3S7dLt0u3S7dLt0u3S7dLt0u3oFvQLegWdAu6Bd2CbkG3oFu0G76h6uEgTuIibqIRnXiIl0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6cYsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZyBJPPMRLjEZkCXAQJ3ERN9GIdFt0W3RbdEOWnMRBnMRF3EQjOvEQLzEajW5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0+3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0u3S7dLt0u3S7dIt6BZ0C7oF3YJuQbegW9At6Bbttn8/4iBO4iJuohGdeIiXSLdBt0G3QbdBt0G3zJLvy2dndh0WHuLnNnZiNGaWPBzESVzETTSiEw+RbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bbkY3o5vRzehmdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzel26Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpFnQLugXdgm5Bt6Bb0C3oFnSLdstOxsJBnMRF3EQjOvEQL5Fug26DboNug26DboNug26DbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxkyUmcxEXcRCM68RAvMRqRJUC6TbpNuk26ZZbMkejEQ7zEaMwseTiIk7iIm0i3RbdFt0W3RbdNt023TbdNt023zJL5S3TiIV5iNGaWPBzESVzETaSb0c3oZnQzujndnG5ON6eb083p5nRzujndnG6Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbpduQbegW9At6BZ0C7oF3YJuQbdot+z6LBzESVzETTSiEw/xEuk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbpxiy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyyy5zJLLLLnMksssucySyywJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglgSyZiZtoRCce4iVGI7IEOIiTSLdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNN6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzujndnG5ON6eb083p5nQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0Q5Z4ohGdmG438RKjEVkCHMRJXMRNNKIT6RZ0i3Jbv9+POIiTuIibaEQnHuIl0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3S7dLt0u3S7dLt0u3S7dLt0u3S7dgm5Bt6Bb0C3oFnQLugXdgm7MksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLB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Eg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLfHQEg8t8dASDy3x0BIPLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSElpSQktKaEkJLSmhJSW0pISWlNCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLamhJTW0pIaW1NCSGlpSQ0tqaEkNLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCSFlrSQktaaEkLLWmhJS20pIWWtNCS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4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/j2xzfShV6Bbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/j2xzfShV6Bbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsNfLuBbzfw7Qa+3cC3G/h2A99u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4Nsf30gXegW+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4Nsf30gXegW+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDb3fw7Q6+3cG3O/h2B9/u4NsdfLuDby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+PYCvr2Aby/g2wv49gK+vYBvL+DbC/j2Ar69gG8v4NsL+Pbyi29vfn4LvhXfZ7pt/veO7zPd1s/viu8z3TbO7zPdLuf3iO+pV93O7zPdXs7vM91++p961U8/U6/G/NuPdB+n5Od3xXfDdz+/p58R36dePb8/0n2cep/fen6f+Tn16vnt5/dZDqdePb/PdKWe32e6Mn2e6epxfo/4PvXq+S34Vnwbvh3fBd8V3w3fSLcj3YF0B9IdSHcg3YF0B9IdSHcg3YF0R6Q7+fbnt+Bb8W34dnwXfFd8N3x3fCNdQbqnXj1O8M9vxbfh2/Fd8F3x3fDd8T3i+9Sr5zfSVaSrSFeRriJdRbqKdBXpKtI1pGtI15CuIV1DuoZ0Deka0jWka0jXka4jXUe6jnQd6TrSdaTrSNeRriPdgnQL0i1ItyDdgnQL0i1ItyDdgnQL0q1ItyLdinQr0q1ItyLdinQr0q1ItyLdhnQb0m1ItyHdhnQb0m1ItyHdhnQb0u1ItyPdjnQ70u1ItyPdjnQ70u1ItyPdgXQH0h1IdyDdgXQH0h1IdyDdgXRHpDv59ue34Fvxbfh2fBd8V3w3fHd8I11ButArh1459MqhVw69cuiVQ68ceuXQK4deOfTKoVcOvXLolUOvHHrl0CuHXjn0yqFXDr1y6JVDrxx65dArh1459MqhVw69cuiVQ68ceuXQK4deOfTKoVcOvXLolUOvHHrl0CuHXjn0yqFXDr1y6JVDrxx65dArh1459MqhVw69cuiVQ68ceuXQK4deOfTKoVcOvXLolUOvHHrl0CuHXjn0yqFXDr1y6JVDrxx65dArh1459MqhVw69cuiVQ68ceuXQK4deOfTKoVcOvXLolUOvHHrl0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrAr0q0KsCvSrQqwK9KtCrCr2q0KsKvarQqwq9qtCrCr2q0KsKvarQqwq9qtCrCr2q0KsKvarQqwq9qtCrCr2q0KsKvarQqwq9qtCrCr2q0KsKvarQqwq9qtCrCr2q0KsKvarQqwq9qtCrCr2q0KsKvarQqwq9qtCrCr2q0KsKvZp8++Pfnt8V3w3fZ7rezu8zXf/YF5p8+/P7TLcc57fi+0y36Pl9plvsP//6l//nb//+L3/7P/7+z//zL//lfz/M/+t//es//ce//Nu//jL/4//9H89/83/8+7/8/e//8n//9//x7//2T//8f/6vf//n//73f/unj3/3l+Pjfz6a2H997ASp/LfHfyy//vnjnzw2mP76+N+h/+2vf7H5T4Y9/slj4+PxT3792WOX7uM/Kh//0UcD/a8f/76d/9X48Kcf/j7+2vSvrs+/K/LXUj/+tV05sPFX949/5M+/0P5X68+/uP51yRz+53/+t//8/wA=","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"ZKPassportCredentialEmitter::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"ZKPassportCredentialEmitter::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::sync_private_state_parameters","fields":[]}}]},{"kind":"struct","path":"ZKPassportCredentialEmitter::verify_and_publish_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::verify_and_publish_parameters","fields":[{"name":"contractProofData","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::ContractProofData","fields":[{"name":"vkeys","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::vkeys","fields":[{"name":"vkey_a","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_b","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_c","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_d","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_e","type":{"kind":"array","length":128,"type":{"kind":"field"}}},{"name":"vkey_f","type":{"kind":"array","length":128,"type":{"kind":"field"}}}]}},{"name":"proofs","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::proofs","fields":[{"name":"proof_a","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_b","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_c","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_d","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_e","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"proof_f","type":{"kind":"array","length":456,"type":{"kind":"field"}}}]}},{"name":"vkey_hashes","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::vkey_hashes","fields":[{"name":"vkey_hash_a","type":{"kind":"field"}},{"name":"vkey_hash_b","type":{"kind":"field"}},{"name":"vkey_hash_c","type":{"kind":"field"}},{"name":"vkey_hash_d","type":{"kind":"field"}},{"name":"vkey_hash_e","type":{"kind":"field"}},{"name":"vkey_hash_f","type":{"kind":"field"}}]}},{"name":"public_inputs","type":{"kind":"struct","path":"ZKPassportCredentialEmitter::public_inputs","fields":[{"name":"input_a","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_b","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"input_c","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"input_d","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"input_e","type":{"kind":"array","length":5,"type":{"kind":"field"}}},{"name":"input_f","type":{"kind":"array","length":5,"type":{"kind":"field"}}}]}}]}},{"name":"msg","type":{"kind":"array","length":7,"type":{"kind":"array","length":31,"type":{"kind":"integer","sign":"unsigned","width":8}}}},{"name":"wormhole_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"token_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"nonce","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Wormhole"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"state","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"sequences","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"receiver_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}},{"name":"token_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000d"}}]}},{"name":"guardian_1","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000011"}}]}},{"name":"guardian_2","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000012"}}]}},{"name":"guardian_3","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000013"}}]}},{"name":"guardian_4","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000014"}}]}},{"name":"guardian_5","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000015"}}]}},{"name":"guardian_6","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000016"}}]}},{"name":"guardian_7","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000017"}}]}},{"name":"guardian_8","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000018"}}]}},{"name":"guardian_9","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000019"}}]}},{"name":"guardian_10","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001a"}}]}},{"name":"guardian_11","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001b"}}]}},{"name":"guardian_12","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001c"}}]}},{"name":"guardian_13","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001d"}}]}},{"name":"guardian_14","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001e"}}]}},{"name":"guardian_15","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000001f"}}]}},{"name":"guardian_16","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000020"}}]}},{"name":"guardian_17","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000021"}}]}},{"name":"guardian_18","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000022"}}]}},{"name":"guardian_19","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000023"}}]}},{"name":"current_guardian_set_index","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000024"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract ZKPassportCredentialEmitter {\n    use dep::aztec::{\n        macros::{\n            functions::private,\n        }, \n        protocol_types::{\n            address::AztecAddress,\n            traits::{Deserialize, Serialize, FromField}\n        }\n    };\n    use dep::std;\n    use dep::wormhole::Wormhole;\n    use dep::token::Token;\n\n    #[derive(Serialize, Deserialize)]\n    struct vkeys {\n        vkey_a: [Field; 128],\n        vkey_b: [Field; 128],\n        vkey_c: [Field; 128],\n        vkey_d: [Field; 128],\n        vkey_e: [Field; 128],\n        vkey_f: [Field; 128],\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct proofs {\n        proof_a: [Field; 456],\n        proof_b: [Field; 456],\n        proof_c: [Field; 456],\n        proof_d: [Field; 456],\n        proof_e: [Field; 456],\n        proof_f: [Field; 456],\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct public_inputs {\n        input_a: [Field; 2],\n        input_b: [Field; 2],\n        input_c: [Field; 10],\n        input_d: [Field; 5],\n        input_e: [Field; 5],\n        input_f: [Field; 5],\n    }\n\n    #[derive(Serialize, Deserialize)]\n    struct vkey_hashes {\n        vkey_hash_a: Field,\n        vkey_hash_b: Field,\n        vkey_hash_c: Field,\n        vkey_hash_d: Field,\n        vkey_hash_e: Field,\n        vkey_hash_f: Field,\n    }\n\n    #[derive(Serialize, Deserialize)]\n    pub struct ContractProofData {\n        vkeys: vkeys,\n        proofs: proofs,\n        vkey_hashes: vkey_hashes,\n        public_inputs: public_inputs,\n    }\n\n    #[private]\n    fn verify_and_publish(\n        contractProofData: ContractProofData,\n        msg: [[u8;31];7], // Format: [zkDonation Arb Address, Arb chain ID, msg1, msg2, msg3, msg4, msg5]\n        wormhole_address: AztecAddress,\n        token_address: AztecAddress, // address of the token to be donated\n        amount: u128, // amount of tokens to be donated on chosen chainID\n        nonce: Field\n    ) {\n        // 1. verify zk passport proofs\n        // proof a,b has 2 public inputs\n        std::verify_proof_with_type(\n            contractProofData.vkeys.vkey_a,\n            contractProofData.proofs.proof_a,\n            contractProofData.public_inputs.input_a,\n            contractProofData.vkey_hashes.vkey_hash_a,\n            1\n        );\n\n        std::verify_proof_with_type(\n            contractProofData.vkeys.vkey_b,\n            contractProofData.proofs.proof_b,\n            contractProofData.public_inputs.input_b,\n            contractProofData.vkey_hashes.vkey_hash_b,\n            1\n        );\n\n        // proof c has 10 public inputs\n        std::verify_proof_with_type(\n            contractProofData.vkeys.vkey_c,\n            contractProofData.proofs.proof_c,\n            contractProofData.public_inputs.input_c,\n            contractProofData.vkey_hashes.vkey_hash_c,\n            1\n        );\n\n        // proof d,e,f have 5 public inputs\n        std::verify_proof_with_type(\n            contractProofData.vkeys.vkey_d,\n            contractProofData.proofs.proof_d,\n            contractProofData.public_inputs.input_d,\n            contractProofData.vkey_hashes.vkey_hash_d,\n            1\n        );\n\n        std::verify_proof_with_type(\n            contractProofData.vkeys.vkey_e,\n            contractProofData.proofs.proof_e,\n            contractProofData.public_inputs.input_e,\n            contractProofData.vkey_hashes.vkey_hash_e,\n            1\n        );\n\n        std::verify_proof_with_type(\n            contractProofData.vkeys.vkey_f,\n            contractProofData.proofs.proof_f,\n            contractProofData.public_inputs.input_f,\n            contractProofData.vkey_hashes.vkey_hash_f,\n            1\n        );\n\n        let bridge_address = AztecAddress::from_field(0x0d071eec273fa0c82825d9c5d2096965a40bcc33ae942714cf6c683af9632504); // TODO: confirm address, rename variable, remove hardcoding\n\n        // 2. Perform zk Donation\n        let _ = Token::at(token_address).transfer_in_private(\n            context.msg_sender(),\n            bridge_address, // should be set to the bridge address but for demo purposes the user can supply it\n            amount,\n            nonce\n        ).call(&mut context);\n\n        // 3. prepare message\n        // MSG = [zkDonation Arb Address, Arb chain ID, Amount, payload]\n\n        // Payload Field 3: Amount as [u8;31]\n        // let amount_field: Field = amount as Field;\n        // let payload3: [u8; 31] = amount_field.to_be_bytes();\n\n        let amount_field: Field = amount as Field;\n        let payload3: [u8; 31] = amount_field.to_le_bytes();\n\n        // Payload Field 4-8: Message\n        // The message is already in the format of 5 u8s, so we can directly use it\n        let wormhole_payload = [msg[0], msg[1], payload3, msg[2], msg[3], msg[4], msg[5], msg[6]];\n                \n        // 4. call publish message\n        // Wormhole signature: fn publish_message_in_private(nonce: u64, payloads: [[u8; 31]; 8], message_fee: u128, consistency: u8, from: AztecAddress, token_nonce: Field)\n        let _ = Wormhole::at(wormhole_address).publish_message_in_private(\n            1, // nonce: u64\n            wormhole_payload, // payloads: [[u8; 31]; 8]\n            2, // message_fee: u128\n            2, // consistency: u8\n            context.msg_sender(), // from: AztecAddress (already unwrapped above)\n            nonce, // token_nonce: Field\n        ).call(&mut context);\n    }\n}","path":"/home/edgar/development/nethermind/aztec-wormhole-app-demo/packages/aztec-contracts/emitter/src/main.nr"},"60":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"61":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"68":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"70":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"71":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"73":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/event/event_selector.nr"},"75":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/hash.nr"},"92":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"96":{"source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"101":{"source":"use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr"},"105":{"source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"107":{"source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"110":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"111":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"112":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"113":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr"},"114":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"115":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr"},"116":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"117":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"133":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr"},"145":{"source":"use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"148":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"152":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"153":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"155":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"156":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"162":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"163":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"165":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr"},"170":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"173":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/version.nr"},"203":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"206":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"207":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"209":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"210":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"212":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"214":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"226":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/edgar/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"291":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"307":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"316":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"330":{"source":"/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"331":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"332":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"342":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"357":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"359":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"360":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"380":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"410":{"source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n","path":"/home/edgar/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/uint-note/src/uint_note.nr"}}}